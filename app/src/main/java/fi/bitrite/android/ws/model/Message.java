package fi.bitrite.android.ws.model;

import android.support.annotation.VisibleForTesting;
import android.text.Html;
import android.text.Spanned;

import java.util.Date;

public class Message {

    public final int id;

    public final int threadId;
    public final int authorId;

    public final Date date;
    public final String rawBody;
    public final String strippedRawBody;
    public final CharSequence body;

    /**
     * Whether this message is new and a notification should be shown for it.
     */
    public final boolean isNew;

    /**
     * Whether this message is already pushed to the webservice. We need this flag for a very short
     * time between a message being successfully sent and the thread being reloaded from the
     * webservice. As we do not get any id for the newly created message, we cannot map the one from
     * the remote to the local one. And since it is possible that one message was successfully sent
     * and another not we need to keep track of that information. When the next reload is done from
     * the webservice, all the temporary local messages which are flagged as pushed are removed.
     * TODO(saemy): Change the webservice to return the message(id) upon successful push.
     */
    public final boolean isPushed;

    public Message(int id, int threadId, int authorId, Date date, String rawBody, boolean isNew,
                   boolean isPushed) {
        this.id = id;
        this.threadId = threadId;
        this.authorId = authorId;
        this.date = date;
        this.rawBody = rawBody;
        this.strippedRawBody = stripBody(rawBody);
        this.body = parseBody(strippedRawBody);
        this.isNew = isNew;
        this.isPushed = isPushed;
    }

    public Message cloneForIsNew(boolean isNew) {
        return new Message(id, threadId, authorId, date, rawBody, isNew, isPushed);
    }
    public Message cloneForIsPushed(boolean isPushed) {
        return new Message(id, threadId, authorId, date, rawBody, isNew, isPushed);
    }

    /**
     * Removes the "\r\n" between two "<p>...</p>"-blocks.
     *
     * WS creates a new "<p>...</p>" block whenever the user presses <enter> to end the current line
     * of a message in the web form.
     * If the user presses <shift>-<enter> a <br/> is added to the current "<p>...</p>"-block.
     */
    @VisibleForTesting
    static String stripBody(String rawBody) {
        if (!rawBody.startsWith("<p>")) {
            // This message was generated by email reply. It is not enclosed by <p>...</p> and uses
            // '\n' for newlines.
            rawBody = "<p>"
                      + rawBody.replace("\r", "")
                              .replace("\n", "<br>")
                      + "</p>";
        }
        return rawBody.replace("\r\n", "");
    }

    /**
     * Returns the html-parsed body and removes the trailing newlines caused by the last paragraph.
     *    - Html.fromHtml("<p>Lorem ipsum</p>") == "Lorem ipsum\n\n"
     *    - parseBody("<p>Lorem ipsum</p>") == "Lorem ipsum"
     */
    @VisibleForTesting
    static CharSequence parseBody(String strippedRawBody) {
        Spanned body = Html.fromHtml(strippedRawBody);

        // Find the last non-whitespace char and trim the body.
        int i = body.length() - 1;
        while (i >= 0 && Character.isWhitespace(body.charAt(i))) {
            --i;
        }
        return body.subSequence(0, i + 1);
    }
}
